name: Build-Sign-Release

on:
  push:
    branches:
    - gh-actions*
    - master
    - main
    - "v?"
    tags:
    - 'v8.0.1*-test'

permissions:
  contents: read

defaults:
  # top-level defaults subkeys apply to jobs
  # run subkeys apply to all steps within all jobs
  run:
    shell: bash

jobs:
  # enable switching on the REUSE_ARTIFACTS GitHub environment secret variable
  # see https://github.community/t/if-expression-with-context-variable/16558/4
  reuse-artifacts:
    environment: PROD
    runs-on: ubuntu-latest
    outputs:
      reuse-artifacts: ${{ steps.set-reuse-artifacts.outputs.reuse-artifacts }}
    steps:
    # note the key must be 'id' and not 'name' here, to be accessed via the steps.<step> syntax above
    - id: set-reuse-artifacts
      run: |
        if [ "$REUSE_ARTIFACTS" == "true" ] || [ "$REUSE_ARTIFACTS" == "True" ]; then
          reuse="TRUE"
        else
          reuse="FALSE"
        fi
        echo "::set-output name=reuse-artifacts::$reuse"
      env:
        REUSE_ARTIFACTS: ${{ secrets.REUSE_ARTIFACTS }}
    - name: debug
      run: |
        echo "reuse: ${{ steps.set-reuse-artifacts.outputs.reuse-artifacts }}"

  preflight-check:
    runs-on: ubuntu-latest
    steps:

    - name: Checkout cli
      uses: actions/checkout@v2

    - name: Check if BUILD_VERSION matches tag ${{ github.ref }}
      run: |
        echo "Git Ref: ${{ github.ref }}"
        echo "BUILD_VERSION: $(cat BUILD_VERSION)"

        # [[ ${{ github.ref }} =~ refs\/tags\/v$(cat BUILD_VERSION) ]]
        # temporary short circut for the development
        exit 0

  shared-values:
    runs-on: ubuntu-latest
    needs: preflight-check
    outputs:
      secrets-environment: ${{ steps.set-secrets-environment.outputs.secrets-environment }}
      build-version: ${{ steps.set-build-version.outputs.build-version }}
      go-version: ${{ steps.set-go-version.outputs.go-version }}
    steps:
    # note the key must be 'id' and not 'name' here, to be accessed via the steps.<step> syntax above

    - name: Set environment
      id: set-secrets-environment
      run: echo "::set-output name=secrets-environment::PROD"

    - name: Checkout cli
      uses: actions/checkout@v2

    - name: Set build version
      id: set-build-version
      run: |
        version=$(cat BUILD_VERSION)
        echo "::set-output name=build-version::$version"

    - name: Set go version
      id: set-go-version
      run: echo "::set-output name=go-version::1.17"

  test-rpm-package:
    name: Test RPM Packages
    needs: build-linux
    runs-on: ubuntu-latest
    container:
      image: fedora
    steps:

    - name: Download Signed Linux Packages
      uses: actions/download-artifact@v2
      with:
        name: cf-cli-linux-rpm-packages

    - name: Display structure of downloaded files
      run: ls -R

    - name: Test RPMs
      run: |
        rpm -q --qf 'FN:\t%{FILENAMES}\nNAME:\t%{NAME}\nPGP:\t%{SIGPGP:pgpsig}\nGPG:\t%{SIGGPG:pgpsig}\n' -p *.rpm

  test-deb-package:
    name: Test Debian Packages
    needs: build-linux
    runs-on: ubuntu-latest
    container:
      image: ubuntu
    steps:

    - name: Download Signed Linux Packages
      uses: actions/download-artifact@v2
      with:
        name: cf-cli-linux-deb-packages

    - name: Display structure of downloaded files
      run: |
        ls -R
        ls *.deb | xargs -n1 dpkg --info

  test-macos:
    name: Test macOS Packages
    needs: build-macos
    runs-on: macos-latest
    steps:

    - name: Download Signed macOS Packages
      uses: actions/download-artifact@v2
      with:
        name: cf-cli-macos-packages

    - name: Inspect macOS packages
      run: |
        ls -R
        pkgutil --check-signature *

  build-linux:
    name: Build Linux
    needs:
    - reuse-artifacts
    - shared-values
    if: ${{ needs.reuse-artifacts.outputs.reuse-artifacts != 'TRUE' }}
    runs-on: ubuntu-latest
    environment: ${{ needs.shared-values.outputs.secrets-environment }}
    steps:

    - name: Setup
      run: |
        echo "BUILD_VERSION=${{ needs.shared-values.outputs.build-version }}" >> $GITHUB_ENV

    - name: Get Build Version
      id: get_build_version
      run: echo "BUILD_VERSION $BUILD_VERSION"

    - name: Checkout cli
      uses: actions/checkout@v2

    - name: Checkout cli-ci
      uses: actions/checkout@v2
      with:
        repository: cloudfoundry/cli-ci.git
        path: cli-ci
        ref: master

    - name: Install Linux Packages
      run: sudo apt update && sudo apt install -y --no-install-recommends fakeroot
    - name: Set up Go
      uses: actions/setup-go@v2
      with:
        go-version: ${{ needs.shared-values.outputs.go-version }}

    - name: Print go environment
      id: go-cache-paths
      run: |
        echo "::set-output name=go-build::$(go env GOCACHE)"
        echo "::set-output name=go-mod::$(go env GOMODCACHE)"
        go env

    - name: Go Assets Cache
      uses: actions/cache@v2
      with:
        path: |
          ${{ steps.go-cache-paths.outputs.go-mod }}
          ${{ steps.go-cache-paths.outputs.go-build }}
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Build Linux
      run: |
        make out/cf-cli_linux_i686
        make out/cf-cli_linux_x86-64

    - name: Store Linux Binaries
      uses: actions/upload-artifact@v2
      with:
        if-no-files-found: error
        name: cf-cli-linux-binaries
        path: out/cf-cli_linux*

    - name: Build RedHat Packages
      env:
        SIGNING_KEY_GPG_ID: ${{ secrets.SIGNING_KEY_GPG_ID }}
      run: |
        set -ex
        set -o pipefail

        root=$PWD

        cat<< EOF >~/.rpmmacros
        $SIGNING_KEY_GPG_ID
        EOF

        RPM_VERSION=${BUILD_VERSION//-/_}

        mkdir -pv $root/packaged

        echo "Build 32-bit RedHat package"
        (
          pushd cli-ci/ci/installers/rpm
        	cp $root/out/cf-cli_linux_i686 cf8
        	cp ../../license/NOTICE .
        	cp ../../license/LICENSE-WITH-3RD-PARTY-LICENSES LICENSE
        	cp ../completion/cf8 cf8.bash
        	echo "Version: ${RPM_VERSION}" > cf-cli.spec
        	cat cf8-cli.spec.template >> cf-cli.spec
        	rpmbuild --target i386 --define "_topdir $(pwd)/build" -bb cf-cli.spec
        	mv build/RPMS/i386/cf8-cli*.rpm $root/packaged/cf8-cli-installer_i686.rpm
          popd
        )


        echo "Build 64-bit RedHat package"
        (
          pushd cli-ci/ci/installers/rpm
        	cp $root/out/cf-cli_linux_x86-64 cf8
        	cp ../../license/NOTICE .
        	cp ../../license/LICENSE-WITH-3RD-PARTY-LICENSES LICENSE
        	cp ../completion/cf8 cf8.bash
        	echo "Version: ${RPM_VERSION}" > cf-cli.spec
        	cat cf8-cli.spec.template >> cf-cli.spec
        	rpmbuild --target x86_64 --define "_topdir $(pwd)/build" -bb cf-cli.spec
        	mv build/RPMS/x86_64/cf8-cli*.rpm $root/packaged/cf8-cli-installer_x86-64.rpm
          popd
        )

    - name: Load GPG key
      env:
        SIGNING_KEY_GPG: ${{ secrets.SIGNING_KEY_GPG }}
      run: |
        echo -n "$SIGNING_KEY_GPG" | base64 --decode | gpg --no-tty --batch --pinentry-mode loopback --import

    - name: View GPG keys
      run: |
        gpg --list-keys

    - name: Sign RedHat Packages
      env:
        SIGNING_KEY_GPG_ID: ${{ secrets.SIGNING_KEY_GPG_ID }}
        SIGNING_KEY_GPG_PASSPHRASE: ${{ secrets.SIGNING_KEY_GPG_PASSPHRASE }}
      run: |
        set -ex
        set -o pipefail

        SUFFIX=8

        mkdir signed-redhat-installer

        cat<< EOF >~/.rpmmacros
        %_gpg_name $SIGNING_KEY_GPG_ID
        EOF

        # mkdir gpg-dir
        # export GNUPGHOME=$PWD/gpg-dir
        # chmod 700 $GNUPGHOME
        # TODO: restore
        # trap "rm -rf $GNUPGHOME" 0

        cp packaged/cf*.rpm   signed-redhat-installer/

        # gpg-connect-agent RELOADAGENT /bye

        # echo "allow-preset-passphrase" > ~/.gnupg/gpg-agent.conf
        # echo ${{secrets.SIGNING_KEY_GPG_PASSPHRASE}} | /usr/lib/gnupg2/gpg-preset-passphrase --preset B94FA54D4D79041DD7966A6E7AE4622DAA833376 #pvt
        # echo ${{secrets.SIGNING_KEY_GPG_PASSPHRASE}} | /usr/lib/gnupg2/gpg-preset-passphrase --preset 5E2EA1C9C49415D8F15E7509A151D2E521CC07EA # pub

        # TODO: consider to add --key-id
        rpmsign --addsign signed-redhat-installer/*.rpm

    - name: Print RPM Signature
      run: rpm -q --qf 'FN:\t%{FILENAMES}\nNAME:\t%{NAME}\nPGP:\t%{SIGPGP:pgpsig}\nGPG:\t%{SIGGPG:pgpsig}\n' -p *.rpm
      working-directory: signed-redhat-installer

    - name: Store Signed Linux RPM Packages
      uses: actions/upload-artifact@v2
      with:
        if-no-files-found: error
        name: cf-cli-linux-rpm-packages
        path: signed-redhat-installer/*.rpm

    # - name: Setup upterm session
    #   env:
    #     AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
    #     AWS_BUCKET_INTEGRATION: ${{ secrets.AWS_BUCKET_INTEGRATION }}
    #     AWS_BUCKET_STAGING: ${{ secrets.AWS_BUCKET_STAGING }}
    #     AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    #     #
    #     DOCKER_HUB_ACCESS_TOKEN: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
    #     DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
    #     #
    #     SIGNING_KEY_GPG: ${{ secrets.SIGNING_KEY_GPG }}
    #     SIGNING_KEY_GPG_ID: ${{ secrets.SIGNING_KEY_GPG_ID }}
    #     SIGNING_KEY_GPG_PASSPHRASE: ${{ secrets.SIGNING_KEY_GPG_PASSPHRASE }}
    #     #
    #     SIGNING_CER_MAC: ${{ secrets.SIGNING_CER_MAC }}
    #     SIGNING_KEYCHAIN_PASSPHRASE: ${{ secrets.SIGNING_KEYCHAIN_PASSPHRASE }}
    #     #
    #     SIGNING_KEY_MAC: ${{ secrets.SIGNING_KEY_MAC }}
    #     SIGNING_KEY_MAC_ID: ${{ secrets.SIGNING_KEY_MAC_ID }}
    #     SIGNING_KEY_MAC_PASSPHRASE: ${{ secrets.SIGNING_KEY_MAC_PASSPHRASE }}
    #     SIGNING_KEY_MAC_PFX: ${{ secrets.SIGNING_KEY_MAC_PFX }}
    #     #
    #     SIGNING_KEY_WINDOWS_ID: ${{ secrets.SIGNING_KEY_WINDOWS_ID }}
    #     SIGNING_KEY_WINDOWS_PASSPHRASE: ${{ secrets.SIGNING_KEY_WINDOWS_PASSPHRASE }}
    #     SIGNING_KEY_WINDOWS_PFX: ${{ secrets.SIGNING_KEY_WINDOWS_PFX }}
    #   if: always()
    #   uses: lhotari/action-upterm@v1
    #   timeout-minutes: 60


    - name: Build Debian Packages
      run: |
        set -ex
        set -o pipefail

        root=$PWD

        mkdir -pv $root/packaged-deb

        echo "Build 32-bit Debian package"
        (
          SIZE="$(BLOCKSIZE=1000 du $root/out/cf-cli_linux_i686 | cut -f 1)"

          pushd cli-ci/ci/installers/deb
            mkdir -p cf/usr/bin cf/usr/share/doc/cf8-cli/ cf/DEBIAN cf/usr/share/bash-completion/completions

            cp copyright_preamble cf/DEBIAN/copyright
            sed 's/^$/ ./' $root/LICENSE >> cf/DEBIAN/copyright
            cat copyright_comment_header >> cf/DEBIAN/copyright
            sed 's/^$/ ./' ../../license/3RD-PARTY-LICENSES >> cf/DEBIAN/copyright

            cp cf/DEBIAN/copyright cf/usr/share/doc/cf8-cli/copyright

            cp ../../license/NOTICE cf/usr/share/doc/cf8-cli
            cp ../../license/LICENSE-WITH-3RD-PARTY-LICENSES cf/usr/share/doc/cf8-cli/LICENSE

            cp control_v8.template cf/DEBIAN/control
            echo "Installed-Size: ${SIZE}" >> cf/DEBIAN/control
            echo "Version: ${BUILD_VERSION}" >> cf/DEBIAN/control
            echo "Architecture: i386" >> cf/DEBIAN/control

            cp ../completion/cf8 cf/usr/share/bash-completion/completions/cf8

            cp $root/out/cf-cli_linux_i686 cf/usr/bin/cf8
            ln -frs cf/usr/bin/cf8 cf/usr/bin/cf

            fakeroot dpkg --build cf cf8-cli-installer_i686.deb
            mv cf8-cli-installer_i686.deb $root/packaged-deb
            rm -rf cf
          popd
        )

        echo "Build 64-bit Debian package"
        (
          SIZE="$(BLOCKSIZE=1000 du $root/out/cf-cli_linux_x86-64 | cut -f 1)"

          pushd cli-ci/ci/installers/deb
            mkdir -p cf/usr/bin cf/usr/share/doc/cf8-cli/ cf/DEBIAN cf/usr/share/bash-completion/completions

            cp copyright_preamble cf/DEBIAN/copyright
            sed 's/^$/ ./' $root/LICENSE >> cf/DEBIAN/copyright
            cat copyright_comment_header >> cf/DEBIAN/copyright
            sed 's/^$/ ./' ../../license/3RD-PARTY-LICENSES >> cf/DEBIAN/copyright

            cp cf/DEBIAN/copyright cf/usr/share/doc/cf8-cli/copyright

            cp ../../license/NOTICE cf/usr/share/doc/cf8-cli
            cp ../../license/LICENSE-WITH-3RD-PARTY-LICENSES cf/usr/share/doc/cf8-cli/LICENSE

            cp control_v8.template cf/DEBIAN/control
            echo "Installed-Size: ${SIZE}" >> cf/DEBIAN/control
            echo "Version: ${BUILD_VERSION}" >> cf/DEBIAN/control
            echo "Architecture: amd64" >> cf/DEBIAN/control

            cp ../completion/cf8 cf/usr/share/bash-completion/completions/cf8

            cp $root/out/cf-cli_linux_x86-64 cf/usr/bin/cf8
            ln -frs cf/usr/bin/cf8 cf/usr/bin/cf

            fakeroot dpkg --build cf cf8-cli-installer_x86-64.deb
            mv cf8-cli-installer_x86-64.deb $root/packaged-deb
          popd
        )

    - name: Print DEB Packages Info
      run: |
        ls -R
        for f in *.deb; do
          echo $f
          dpkg --info $f
        done
      working-directory: packaged-deb

    - name: Store Debian Packages
      uses: actions/upload-artifact@v2
      with:
        if-no-files-found: error
        name: cf-cli-linux-deb-packages
        path: packaged-deb/*.deb

  build-macos:
    name: Build macOS
    needs:
    - reuse-artifacts
    - shared-values
    if: ${{ needs.reuse-artifacts.outputs.reuse-artifacts != 'TRUE' }}
    runs-on: macos-latest
    environment: ${{ needs.shared-values.outputs.secrets-environment }}
    steps:

    - name: Setup
      run: |
        echo "BUILD_VERSION=${{ needs.shared-values.outputs.build-version }}" >> $GITHUB_ENV

    - name: Get Build Version
      id: get_build_version
      run: echo "BUILD_VERSION $BUILD_VERSION"

    - name: Checkout
      uses: actions/checkout@v2
      # with:
      #   fetch-depth: 0

    - name: Checkout cli-ci
      uses: actions/checkout@v2
      with:
        repository: cloudfoundry/cli-ci.git
        path: cli-ci
        ref: master

    - name: Checkout bomutils
      uses: actions/checkout@v2
      with:
        repository: hogliux/bomutils.git
        ref: 0.2
        path: bomutils

    - name: Build bomutils
      working-directory: bomutils
      run: make

    - name: Set up Go
      uses: actions/setup-go@v2
      with:
        go-version: ${{ needs.shared-values.outputs.go-version }}

    - name: Update Homebrew
      run: |
        # brew tap mitchellh/gon
        brew tap pivotalsoftware/gon
        brew update --preinstall
        cat "$(brew --repository)/Library/Taps/pivotalsoftware/homebrew-gon/gon.rb" > .github/brew-formulae

    - name: Configure Homebrew cache
      uses: actions/cache@v2
      with:
        path: |
          ~/Library/Caches/Homebrew/gon--*
          ~/Library/Caches/Homebrew/downloads/*--gon-*
        key: brew-${{ hashFiles('.github/brew-formulae') }}
        restore-keys: brew-

    - name: Install Homebrew dependencies
      run: |
        env HOMEBREW_NO_AUTO_UPDATE=1 brew install pivotalsoftware/gon/gon coreutils

    - name: Print go environment
      id: go-cache-paths
      run: |
        echo "::set-output name=go-build::$(go env GOCACHE)"
        echo "::set-output name=go-mod::$(go env GOMODCACHE)"
        go env

    - name: Go Assets Cache
      uses: actions/cache@v2
      with:
        path: |
          ${{ steps.go-cache-paths.outputs.go-mod }}
          ${{ steps.go-cache-paths.outputs.go-build }}
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Build macOS Binaries
      run: |
        make out/cf-cli_osx
        make out/cf-cli_osx_arm

    - name: Store macOS Binaries
      uses: actions/upload-artifact@v2
      with:
        if-no-files-found: error
        name: cf-cli-macos-binaries
        path: out/cf-cli*

    - name: Build macOS Installer
      run: |
        set -ex
        set -o pipefail

        root=$PWD

        mkdir -pv $root/packaged

        echo "Building OS X installer"
        (
        SIZE="$(BLOCKSIZE=1000 du $root/out/cf-cli_osx | cut -f 1)"

        pushd cli-ci/ci/installers/osx_v8
          sed -i -e "s/VERSION/${BUILD_VERSION}/g" Distribution
          sed -i -e "s/SIZE/${SIZE}/g" Distribution
          mkdir -p cf-cli/usr/local/bin cf-cli/usr/local/share/doc/cf8-cli

          cp $root/out/cf-cli_osx cf-cli/usr/local/bin/cf8
          gln -frs cf-cli/usr/local/bin/cf8 cf-cli/usr/local/bin/cf
          cp ../../license/NOTICE cf-cli/usr/local/share/doc/cf8-cli
          cp ../../license/LICENSE-WITH-3RD-PARTY-LICENSES cf-cli/usr/local/share/doc/cf8-cli/LICENSE
          chmod -R go-w cf-cli
          pushd cf-cli
            find usr | cpio -o --format=odc | gzip -c > ../Payload
          popd

          $root/bomutils/build/bin/ls4mkbom cf-cli | sed 's/1000\/1000/0\/80/' > bom_list
          mkbom -i bom_list Bom
          mv Bom Payload com.cloudfoundry.cf8-cli.pkg
          xar -c --compression none -f cf8-cli-installer_osx.pkg com.cloudfoundry.cf8-cli.pkg Distribution
          mv cf8-cli-installer_osx.pkg $root/packaged/cf8-cli-installer_osx.pkg
        popd
        )

    - name: Load macos key
      env:
        SIGNING_TEST_CA_MAC: ${{ secrets.SIGNING_TEST_CA_MAC }}
        SIGNING_KEYCHAIN_PASSPHRASE: ${{ secrets.SIGNING_KEYCHAIN_PASSPHRASE }}

        SIGNING_KEY_MAC: ${{ secrets.SIGNING_KEY_MAC }}
        SIGNING_KEY_MAC_ID: ${{ secrets.SIGNING_KEY_MAC_ID }}
        SIGNING_KEY_MAC_PASSPHRASE: ${{ secrets.SIGNING_KEY_MAC_PASSPHRASE }}
        SIGNING_KEY_MAC_PFX: ${{ secrets.SIGNING_KEY_MAC_PFX }}

      run: |
        echo -n "$SIGNING_KEY_MAC_PFX" | base64 --decode > mac-signing-key.p12
        # security delete-keychain test-keychain || echo test-keychain not found
        security list-keychains -d user -s login

        ORIGINAL_KEYCHAIN="$(security default-keychain | sed -e 's/[ "]*\([^"]*\)[ "]*/\1/')"
        KEYCHAIN_PATH="$HOME/Library/Keychains/build.keychain-db"

        # Create build keychain
        security create-keychain -p "$SIGNING_KEYCHAIN_PASSPHRASE" "$KEYCHAIN_PATH"
        # trap "security delete-keychain $KEYCHAIN_PATH" 0

        # Append build keychain to the user domain
        security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | sed s/\"//g)

        # Remove relock timeout
        security set-keychain-settings "$KEYCHAIN_PATH"

        # Unlock build keychain
        security unlock-keychain -p "$SIGNING_KEYCHAIN_PASSPHRASE" "$KEYCHAIN_PATH"

        # Add certificate to keychain
        security import mac-signing-key.p12 -k "$KEYCHAIN_PATH" -P "$SIGNING_KEY_MAC_PASSPHRASE" -A -T $(which codesign) -T $(which productsign)

        # Enable codesigning from a non user interactive shell
        security set-key-partition-list -S apple-tool:,apple:, -s -k "$SIGNING_KEYCHAIN_PASSPHRASE" -D "${IDENTITY_CERTIFICATE}" -t private "$KEYCHAIN_PATH" || echo set-key-partition-list private failed
        # security set-key-partition-list -S apple-tool:,apple: -s -k "$SIGNING_KEYCHAIN_PASSPHRASE" "$KEYCHAIN_PATH"
        # swap keychains
        # BACKUP_KEYCHAIN="${ORIGINAL_KEYCHAIN}.bak"
        # cp "$ORIGINAL_KEYCHAIN" "$BACKUP_KEYCHAIN"
        # cp "$KEYCHAIN_PATH" "$ORIGINAL_KEYCHAIN"
        # security find-key | grep '0x00000001'
        # cleanup keys
        # rm ca.crt
        rm mac-signing-key.p12

        # Delete build keychain
        # security delete-keychain "$KEYCHAIN_PATH"

        # default again user login keychain
        # security list-keychains -d user -s login.keychain


    - name: Sign macOS
      env:
        SUFFIX: 8
        SIGNING_KEY_MAC_ID: ${{ secrets.SIGNING_KEY_MAC_ID }}
        SIGNING_KEY_MAC_PASSPHRASE: ${{ secrets.SIGNING_KEY_MAC_PASSPHRASE }}
      run: |

        root=$PWD

        mkdir -pv signed-osx-installer

        productsign --timestamp \
          --sign "$SIGNING_KEY_MAC_ID" \
          "$root/packaged/cf${SUFFIX}-cli-installer_osx.pkg" \
          "signed-osx-installer/cf${SUFFIX}-cli-installer_${BUILD_VERSION}_osx.pkg"

    - name: Store macOS Signed Packages
      uses: actions/upload-artifact@v2
      with:
        if-no-files-found: error
        name: cf-cli-macos-packages
        path: signed-osx-installer/*.pkg


  windows-signing:
    needs:
    - reuse-artifacts
    - shared-values
    if: ${{ needs.reuse-artifacts.outputs.reuse-artifacts != 'TRUE' }}
    runs-on: windows-2019
    environment: ${{ needs.shared-values.outputs.secrets-environment }}
    defaults:
      run:
        shell: pwsh
    steps:
      # - name: debug
      #   run: |
      #     Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\x64"
      #     echo "---"
      #     Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22000.0\x64"
      - name: Checkout
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
      - name: Set up Go
        uses: actions/setup-go@v2
        with:
          go-version: ${{ needs.shared-values.outputs.go-version }}

      - name: Get build-time dependencies
        run: |
          choco install --no-progress --limit-output -y make
          go install github.com/akavel/rsrc@v0.10.2

      - name: Build CF CLI for Windows
        run: |
          Get-Command make
          Get-Item Makefile
          make out/cf-cli_win32.exe
          make out/cf-cli_winx64.exe

      # - name: import windows cert
      #   run: |
      #     Get-ChildItem
      #     $pass = ConvertTo-SecureString -String "$SIGNING_KEY_WINDOWS_PASSPHRASE" -AsPlainText
      #     Import-PfxCertificate -FilePath C:\cert.pfx -CertStoreLocation Cert:\LocalMachine\My -Password $pass
      #   env:
      #     SIGNING_KEY_WINDOWS_PFX: ${{ secrets.SIGNING_KEY_WINDOWS_PFX }}
      #     SIGNING_KEY_WINDOWS_PASSPHRASE: ${{ secrets.SIGNING_KEY_WINDOWS_PASSPHRASE }}

      - name: write windows cert
        run: |
          $pass = ConvertTo-SecureString -String "$env:SIGNING_KEY_WINDOWS_PASSPHRASE" -AsPlainText
          [Convert]::FromBase64String($env:SIGNING_KEY_WINDOWS_PFX) | Set-Content -Path $env:RUNNER_TEMP\cert.pfx -AsByteStream

          # # Import-PfxCertificate returns an object with details of the imported cert
          # $certImport = Import-PfxCertificate -FilePath $env:RUNNER_TEMP\cert.pfx -CertStoreLocation Cert:\CurrentUser\My -Password $pass
          # # set thumbprint env var for later use
          # echo "CERT_THUMBPRINT=$($certImport.Thumprint)" >> $GITHUB_ENV
        env:
          SIGNING_KEY_WINDOWS_PFX: ${{ secrets.SIGNING_KEY_WINDOWS_PFX }}
          SIGNING_KEY_WINDOWS_PASSPHRASE: ${{ secrets.SIGNING_KEY_WINDOWS_PASSPHRASE }}

      - name: Sign windows binaries
        run: |
          .\win\sign-windows-binary.ps1 -BinaryFilePath out\cf-cli_win32.exe
          .\win\sign-windows-binary.ps1 -BinaryFilePath out\cf-cli_winx64.exe
        env:
          SIGNING_KEY_WINDOWS_PFX: ${{ secrets.SIGNING_KEY_WINDOWS_PFX }}
          SIGNING_KEY_WINDOWS_PASSPHRASE: ${{ secrets.SIGNING_KEY_WINDOWS_PASSPHRASE }}

      - name: View binary signatures
        run: |
          Get-AuthenticodeSignature -Verbose -ErrorAction Stop .\out\cf-cli_win32.exe
          Get-AuthenticodeSignature -Verbose -ErrorAction Stop .\out\cf-cli_winx64.exe

      # - name: enable ssh
      #   if: always()
      #   run: |
      #     Get-WindowsCapability -Online
      #     $componentName = $(Get-WindowsCapability -Online |Where-Object Name -like 'OpenSSH.Server*').Name
      #     Add-WindowsCapability -Online -Name $componentName
      #     Get-NetFirewallRule -Name "OpenSSH-Server-In-TCP"

      - name: Save signed binaries as a GitHub Action Artifact
        uses: actions/upload-artifact@v2
        with:
          name: cf-cli-windows-binaries
          if-no-files-found: error
          path: |
            out/cf-cli_win32.exe
            out/cf-cli_winx64.exe

      - name: Install innosetup
        run: .\win\install-innosetup.ps1

      - name: Run innosetup
        run: |
          mkdir "$env:RUNNER_TEMP\x64"
          .\win\run-innosetup.ps1 -InstallerOutputFilePath "$env:RUNNER_TEMP\x64\cf8_installer.exe"

      - name: Sign windows installer
        run: .\win\sign-windows-binary.ps1 -BinaryFilePath "$env:RUNNER_TEMP\x64\cf8_installer.exe"
        env:
          SIGNING_KEY_WINDOWS_PFX: ${{ secrets.SIGNING_KEY_WINDOWS_PFX }}
          SIGNING_KEY_WINDOWS_PASSPHRASE: ${{ secrets.SIGNING_KEY_WINDOWS_PASSPHRASE }}

      - name: View installer signature
        run: Get-AuthenticodeSignature -Verbose -ErrorAction Stop "$env:RUNNER_TEMP\x64\cf8_installer.exe"

      - name: Arrange files for upload
        # note the -Path flag takes comma-delimited args
        run: Copy-Item -Destination "$env:RUNNER_TEMP\x64" -Path win\LICENSE,win\NOTICE

      # - name: name windows edge artifact
      #   if: ${{ github.ref_type != 'tag' }}
      #   # set environment vars for subsequent steps. see: https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable
      #   run: |
      #     echo "INSTALLER_RELEASE_VERSION=edge" >> $GITHUB_ENV
      #     echo "INSTALLER_ZIP_FILENAME=cf8-cli-installer_edge_winx64.zip" >> $GITHUB_ENV
      #     # echo "BINARY_ZIP_FILENAME: " >> ENV
      # - name: name windows release artifact
      #   if: ${{ github.ref_type == 'tag' }}
      #   # set environment vars for subsequent steps. see: https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable
      #   run: |
      #     # strip leading v to go from tag -> semver
      #     INSTALLER_RELEASE_VERSION=$(echo ${{ github.ref_name }} | tr -d v)
      #     echo "INSTALLER_RELEASE_VERSION=${INSTALLER_RELEASE_VERSION}" >> $GITHUB_ENV
      #     echo "INSTALLER_ZIP_FILENAME=cf8-cli-installer_${INSTALLER_RELEASE_VERSION}_winx64.zip" >> $GITHUB_ENV
      #     cat $GITHUB_ENV
      # - name: zip windows artifact
      #   run: |
      #     pushd signed/cf8-cli-installer_winx64
      #       zip "$INSTALLER_ZIP_FILENAME" *
      #       ls
      #     popd

      - name: zip windows artifact
        run: |
          pushd "$env:RUNNER_TEMP\x64"
            # strip leading v to go from tag -> semver
            $installer_release_version="${{ github.ref_name }}".Replace("v", "")
            $installer_zip_filename="$env:RUNNER_TEMP\cf8-cli-installer_${installer_release_version}_winx64.zip"
            Compress-Archive -DestinationPath "$installer_zip_filename" -Path *
          popd
          Get-ChildItem "$env:RUNNER_TEMP"

      - name: Save 64-bit installer and dist files as a GitHub Action Artifact
        uses: actions/upload-artifact@v2
        with:
          name: cf-cli-windows-packages
          if-no-files-found: error
          path: ${{ runner.temp }}/cf8-cli-installer*winx64.zip

      # - name: ssh session
      #   if: always()
      #   run: |
      #     Start-Service sshd
      #     echo "IP address below:"
      #     Get-NetIPAddress | Select-Object -Property IPAddress
      #     sleep 3600
      #     Stop-Service sshd

      # # - name: Cat GoReleaser config
      # #   run: cat dist/config.yaml
      # # - name: GoReleaser schema
      # #   uses: goreleaser/goreleaser-action@v2
      # #   with:
      # #     distribution: goreleaser
      # #     version: latest
      # #     args: jsonschema

  upload-artifacts:
    if: false
    name: Upload to S3
    runs-on: ubuntu-latest
    needs: [ build-linux, test-macos, test-rpm-package, test-deb-package ]

    steps:
    - name: Upload to S3
      run: |
        echo "Upload to S3"
        # set -ex

        # if [ "$TARGET_MAJOR_VERSION" == "7" ]; then
        #  BUCKET_PREFIX=v7-
        # elif [ "$TARGET_MAJOR_VERSION" == "8" ]; then
        #  BUCKET_PREFIX=v8-
        # else
        #  BUCKET_PREFIX=
        # fi

        # aws s3 cp repackaged-binaries-and-installers/ s3://${BUCKET_PREFIX}cf-cli-releases/releases/v${BUILD_VERSION}/ --recursive
        # aws s3 cp signed-osx-installer/ s3://${BUCKET_PREFIX}cf-cli-releases/releases/v${BUILD_VERSION}/ --recursive
        # aws s3 cp signed-redhat-installer/ s3://${BUCKET_PREFIX}cf-cli-releases/releases/v${BUILD_VERSION}/ --recursive
        # aws s3 cp signed-windows-zips/ s3://${BUCKET_PREFIX}cf-cli-releases/releases/v${BUILD_VERSION}/ --recursive

#################################
######## Release Section ########
#################################

  s3-upload:
    if: ${{ github.ref_type == 'tag' }}
    runs-on: ubuntu-latest
    needs:
      - build-linux
      - build-macos
      - windows-signing
    environment: DEV
    permissions:
      actions: read
    steps:
    - name: get semver version
      # set environment var for subsequent steps. see: https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable
      run: |
        INSTALLER_RELEASE_VERSION=$(echo ${{ github.ref_name }} | tr -d v)
        echo "INSTALLER_RELEASE_VERSION=${INSTALLER_RELEASE_VERSION}" >> $GITHUB_ENV

    - name: Download signed artifacts
      uses: actions/download-artifact@v2
      with:
        path: signed # download all artifacts to 'signed/'
    # - name: Download previous artifacts
    #   uses: pivotalsoftware/action-download-artifact@v2
    #   with:
    #     workflow: ${{ env.REUSE_ARTIFACT_WORKFLOW }}
    #     run_id: ${{ env.REUSE_ARTIFACT_RUN_ID }}
    #     path: signed
    - name: debug
      run: ls -R signed

    - name: rearrange artifacts before upload
      run: |
        mkdir upload
        cp -t upload  \
          signed/cf-cli-linux-rpm-packages/cf*rpm \
          signed/cf-cli-linux-deb-packages/cf*deb \
          signed/cf-cli-macos-packages/cf*pkg \
          signed/cf-cli-windows-packages/cf*zip

    - name: Upload installers to CLAW S3 bucket
      if: ${{ github.ref_type == 'tag' }}
      # forked for security considerations
      uses: pivotalsoftware/s3-sync-action@v0.5.2 #pinned to no-default-region change
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
        SOURCE_DIR: upload
        DEST_DIR: "v8-cf-cli-releases/releases/v${{ env.INSTALLER_RELEASE_VERSION }}"

    - name: Instruct human to update CLAW
      run: |
        echo "Please go to https://github.com/cloudfoundry/CLAW/blob/develop/claw-variables.yml and add the following line to the file:"
        echo
        echo "- ${INSTALLER_RELEASE_VERSION}"

    - name: list S3
      uses: docker://amazon/aws-cli:latest
      with:
        args: s3 ls --region us-east-1 "${{ env.AWS_S3_BUCKET }}/v8-cf-cli-releases/releases/"
      env:
        AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        INSTALLER_RELEASE_VERSION: ${{ env.INSTALLER_RELEASE_VERSION }}


  github-release-draft:
    if: ${{ github.ref_type == 'tag' }}
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: write
    needs:
      - build-linux
      - build-macos
      - windows-signing
    steps:
    - name: Download signed artifacts
      uses: actions/download-artifact@v2
      with:
        path: signed # download all artifacts to 'signed/'
    # - name: Download previous artifacts
    #   uses: pivotalsoftware/action-download-artifact@v2
    #   with:
    #     workflow: ${{ env.REUSE_ARTIFACT_WORKFLOW }}
    #     run_id: ${{ env.REUSE_ARTIFACT_RUN_ID }}
    #     path: signed
    - name: debug
      run: ls -R signed

    - name: Create draft release
      uses: softprops/action-gh-release@v1
      with:
        draft: true
        fail_on_unmatched_files: true
        files: |
          signed/cf-cli-linux-rpm-packages/cf*rpm
          signed/cf-cli-linux-deb-packages/cf*deb
          signed/cf-cli-macos-packages/cf*pkg
          signed/cf-cli-windows-binaries/*.exe
          signed/cf-cli-windows-packages/*.zip

  # list_s3:
  #   environment: DEV
  #   runs-on: ubuntu-latest
  #   needs: s3-upload
  #   steps:
  #     - uses: docker://amazon/aws-cli:latest
  #       with:
  #         args: s3 ls --region us-east-1 "${{ env.AWS_S3_BUCKET }}/v8-cf-cli-releases/releases/v${{ env.INSTALLER_RELEASE_VERSION }}"
  #       env:
  #         AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}


#######################################################################
# ------------------------------------------------------------------- #
#######################################################################


# Update:
# - CLAW x2
# - Debian
# - Homebrew
# - Docker


        # AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        # AWS_BUCKET_INTEGRATION: ${{ secrets.AWS_BUCKET_INTEGRATION }}
        # AWS_BUCKET_STAGING: ${{ secrets.AWS_BUCKET_STAGING }}
        # AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        #
        # DOCKER_HUB_ACCESS_TOKEN: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
        # DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
        #
        # SIGNING_KEY_GPG: ${{ secrets.SIGNING_KEY_GPG }}
        # SIGNING_KEY_GPG_ID: ${{ secrets.SIGNING_KEY_GPG_ID }}
        # SIGNING_KEY_GPG_PASSPHRASE: ${{ secrets.SIGNING_KEY_GPG_PASSPHRASE }}
        #
        # SIGNING_CER_MAC: ${{ secrets.SIGNING_CER_MAC }}
        # SIGNING_KEYCHAIN_PASSPHRASE: ${{ secrets.SIGNING_KEYCHAIN_PASSPHRASE }}
        #
        # SIGNING_KEY_MAC: ${{ secrets.SIGNING_KEY_MAC }}
        # SIGNING_KEY_MAC_ID: ${{ secrets.SIGNING_KEY_MAC_ID }}
        # SIGNING_KEY_MAC_PASSPHRASE: ${{ secrets.SIGNING_KEY_MAC_PASSPHRASE }}
        # SIGNING_KEY_MAC_PFX: ${{ secrets.SIGNING_KEY_MAC_PFX }}
        #
        # SIGNING_KEY_WINDOWS_ID: ${{ secrets.SIGNING_KEY_WINDOWS_ID }}
        # SIGNING_KEY_WINDOWS_PASSPHRASE: ${{ secrets.SIGNING_KEY_WINDOWS_PASSPHRASE }}
        # SIGNING_KEY_WINDOWS_PFX: ${{ secrets.SIGNING_KEY_WINDOWS_PFX }}

# cf-cli-binaries.tgz
# cf-cli_linux_i686
# cf-cli_linux_x86-64
# cf-cli_osx
# cf-cli_win32.exe
# cf-cli_winx64.exe

# vim: set sw=2 ts=2 sts=2 et tw=78 foldlevel=2 fdm=indent nospell:
